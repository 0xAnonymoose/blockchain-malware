import { bep20, pancakeLP } from './abi.mjs';
import fetch from 'node-fetch';
import { _loadCache, _saveCache, web3 } from './utils.mjs';

export async function scrapeLP(addr, tokenDecimals = 18) {

    let liquidityPair = await new web3.eth.Contract( pancakeLP, addr );
    let reserves = await liquidityPair.methods.getReserves().call();
    let rawsupply = await liquidityPair.methods.totalSupply().call();
    
    let reserveBNB = parseFloat(web3.utils.fromWei(reserves[1]));
    let reserveTokens = parseInt(reserves[0])/(10**parseInt(tokenDecimals));
    let supply = parseFloat(web3.utils.fromWei(rawsupply));
    
    //console.log({name, reserveBNB, reserveTokens, supply});
    return [ reserveBNB, reserveTokens, supply ];
}

export async function findLPs ( contract, amount = 10000000000000 ) {

let url = 'https://pathfinder.1inch.io/v1.2/chain/56/router/v4/quotes?deepLevel=2&mainRouteParts=10&parts=50&virtualParts=50&walletAddress=null&fromTokenAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
+'&toTokenAddress='+contract
+'&amount='+amount
+ "&gasPrice=20000000000&protocolWhiteList=BURGERSWAP,PANCAKESWAP,VENUS,JULSWAP,BAKERYSWAP,BSC_ONE_INCH_LP,ACRYPTOS,BSC_DODO,APESWAP,SPARTAN,SPARTAN_V2,VSWAP,VPEGSWAP,HYPERSWAP,BSC_DODO_V2,SWAPSWIPE,ELLIPSIS_FINANCE,BSC_NERVE,BSC_SMOOTHY_FINANCE,CHEESESWAP,BSC_PMM1,PANCAKESWAP_V2,MDEX,WARDEN,WAULTSWAP,BSC_ONE_INCH_LIMIT_ORDER,BSC_ONE_INCH_LIMIT_ORDER_V2,BSC_PMM3,BSC_PMM7,ACSI_FINANCE,GAMBIT_FINANCE,JETSWAP,BSC_UNIFI,BSC_PMMX,BSC_KYBER_DMM,BSC_BI_SWAP,BSC_DOPPLE,BABYSWAP,BSC_PMM2MM,WOOFI,BSC_ELK,BSC_SYNAPSE,BSC_AUTOSHARK,BSC_CAFE_SWAP,BSC_PMM5,PLANET_FINANCE,BSC_ANNEX_FINANCE,BSC_ANNEX_SWAP,BSC_RADIOSHACK&protocols=BURGERSWAP,PANCAKESWAP,VENUS,JULSWAP,BAKERYSWAP,ACRYPTOS,BSC_DODO,APESWAP,SPARTAN,SPARTAN_V2,VSWAP,VPEGSWAP,HYPERSWAP,BSC_DODO_V2,SWAPSWIPE,ELLIPSIS_FINANCE,BSC_NERVE,BSC_SMOOTHY_FINANCE,CHEESESWAP,PANCAKESWAP_V2,MDEX,WARDEN,WAULTSWAP,ACSI_FINANCE,GAMBIT_FINANCE,JETSWAP,BSC_UNIFI,BSC_KYBER_DMM,BSC_BI_SWAP,BSC_DOPPLE,BABYSWAP,WOOFI,BSC_ELK,BSC_SYNAPSE,BSC_AUTOSHARK,BSC_CAFE_SWAP,PLANET_FINANCE,BSC_ANNEX_FINANCE,BSC_ANNEX_SWAP,BSC_RADIOSHACK&deepLevels=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1&mainRoutePartsList=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1&partsList=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1&virtualPartsList=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";

  let d = await fetch(url);
  let j = await d.json();
  let markets = [];
  
  //console.log(j);
  
  for (let r of j.results) {
    //console.log(r);
    for (let route of r.routes) {
      let sr = route.subRoutes;
      markets.push( sr[0][0].market );
    }
  }
  
  return markets;
}

export async function getTxnByAccount(acct, firstBlock, endBlock, cache = true) {

  // check Cache
  let cname = 'cache/transactions_'+acct+'_'+firstBlock+'_'+endBlock+'.json';
  if (cache) {
    let cdata = _loadCache(cname);
    if (cdata != null) { return cdata; }
  }
  
  // make request
  let url = 'https://api.bscscan.com/api?module=account&action=txlist'
     + '&address='+acct
     + '&startblock='+firstBlock+'&endblock='+endBlock+'&sort=desc&apikey='+process.env.BSCSCAN_API_KEY;
   
  let d = await fetch(url);
  let j = await d.json();

  // if successful, cache and return
  if (j.status != '1') {
    console.error(acct,j);
    return [];
  } else {
    if (cache) { _saveCache(cname, j.result); }
    return j.result;
  }

}

export async function contractInfo(addr) {
  // check Cache
  let cname = 'cache/contractInfo_'+addr+'.json';
  let cdata = _loadCache(cname);
  if (cdata != null) { return cdata; }
  
  const token_abi = await new web3.eth.Contract( bep20, addr );
  let r;
  try {
    r = {
      contractAddress: addr,
      totalSupply: await token_abi.methods.totalSupply().call(),
      symbol: await token_abi.methods.symbol().call(),
      name: await token_abi.methods.name().call(),
      decimals: await token_abi.methods.decimals().call()
    }
  }catch(err) {
    r = {err};
  }
  
  _saveCache(cname, r);
  return r;
}

