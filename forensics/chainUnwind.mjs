import {setTimeout} from "timers/promises";
import { getTxnByAccount, contractInfo } from './bscscan-api.mjs';
import { web3 } from './utils.mjs';

const root = process.env.SCAM_ROOT || '0x8bc50c1d90109d2603e51498b419f9cd499b8280';
const exchange1 = '0x635308e731a878741bfec299e67f5fd28c7553d9';
const exchange2 = '0x2d964ee844c35a72c6a9d498d54c8a9910cf6914';
const exchange3 = '0x975d9bd9928f398c7e01f6ba236816fa558cd94b';

let targets = [];
let visited = [root, exchange1, exchange2, exchange3];

let total_value = BigInt(0);
targets.push(process.argv[2]);
let firstBlock = parseInt(process.argv[3]) || 18000000;
let endBlock = parseInt(process.argv[4]) || 20000000;

let noBack = process.argv[5] == 'noback';
let noFront = process.argv[5] == 'nofront';

let chainBlocks = {};
  
while (targets.length > 0) {

  let target = targets.pop();
  visited.push(target);

  let txn = await getTxnByAccount(target, chainBlocks[target] || firstBlock, endBlock);
  if (txn.length < 4) {
    console.log('Chain broken dead end', target);
    continue;
  }
  
  if (txn[0].from == target && txn[txn.length-1].to == target) {
    let cto = txn[0].to;
    
    /* Find largest transaction in the first 4 */
    let vfrom = BigInt(0);
    let cfrom = null;
    
    for (let i = 1; i<=4; i++) {
      if (BigInt(txn[txn.length-i].value) > vfrom) {
        cfrom = txn[txn.length-i].from;
        vfrom = BigInt(txn[txn.length-i].value);
      }
    }        

    console.log('Chain detected block', txn[0].blockNumber, 'address', target);    
    console.log('  From', cfrom, '   To', cto);
    
    if (cfrom == root) {     console.info('  >>> CHAIN STARTS FROM ROOT!');  }
    if (cto == root)   {     console.info('  >>> CHAIN ENDS AT ROOT!');      }
    
    // when visiting this chainto make sure we dont start from before this link
    if (!visited.includes(cto)   && !targets.includes(cto) && !noFront)   { targets.push(cto); chainBlocks[cto] = txn[0].blockNumber; }
    if (!visited.includes(cfrom) && !targets.includes(cfrom) && !noBack) { targets.push(cfrom); }
    
    let scamToken = null;
    
    for (let t of txn) {
      if (t.to=='') { 
         let info = await contractInfo(t.contractAddress);    
         if (info.name) { scamToken = info; scamToken.txn = t; }
         console.log('  Malware Contract:', t.contractAddress, 'length', t.input.length,'info', info.name, info.symbol, info.decimals, info.totalSupply );
      }
    }

    let value = BigInt(txn[0].value) - BigInt(vfrom);
    total_value += value;
    console.log('  Scam Value:', web3.utils.fromWei(value.toString()));
    
    if (scamToken) {
        let row = [target, scamToken.contractAddress,
                   scamToken.txn.blockNumber, scamToken.txn.input.length,
                   scamToken.name, scamToken.symbol, scamToken.decimals, scamToken.totalSupply,
                   web3.utils.fromWei(value.toString())];
        console.error(row.join(','));
    }
  } else {
    console.log('Chain broken hit trunk?', target);
  }
  
  //await setTimeout(500);
}

console.log('Total value:', web3.utils.fromWei(total_value.toString()));
