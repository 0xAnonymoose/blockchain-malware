import Web3 from 'web3';
import { bep20 } from './abi.mjs';
import { setTimeout } from 'timers/promises';

let web3;

const PAIR_CREATED = "0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9";
const LP_MINTED = "0x4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f";
const LP_SYNC = "0x1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1";

const TOKEN_WBNB = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';

var last_block_time = Date.now();
var lp_info = {};
var lp_list = [];

function let_pad(v, p=64) { return "0x"+v.substring(2).padStart(64,'0'); }
function left_unpad(v)    { return "0x"+v.substring(2).replace(/^0+/, ''); }
function data_to_uint256(data) {
   let tmp = data.substring(2);
   let a = [];
   for (; tmp.length > 0; tmp = tmp.substring(64)) {
     a.push(left_unpad('0x'+tmp.substring(0,64)));
   }
   return a;
}

async function tokenInfo(addr) {
  let info = { addr };
  
  try {
    const token_abi = await new web3.eth.Contract( bep20, addr );
    info.symbol = await token_abi.methods.symbol().call();
    info.name = await token_abi.methods.name().call();
  } catch(e) {
    console.error('tokeninfo failed', addr);
  }
  
  return info;
}

var txnQueue = [];

function interestingPair(addr) {
  return (lp_list.indexOf(addr) > -1);
}

async function processQueue() { 
  while (txnQueue.length > 0) {
     let txnid = txnQueue.shift();
     //console.log('processQueue', txnid);

  }
}

async function pairCreated(log) { 
  let router = log.address.toLowerCase();
  let asset0 = left_unpad(log.topics[1]).toLowerCase();
  let asset1 = left_unpad(log.topics[2]).toLowerCase();
  let pair = left_unpad(log.data.substring(0,66)).toLowerCase();
  
  if (lp_list.indexOf(pair) > -1) {
    console.log('pairCreated', pair, 'duplicate');
    return;
  }
  
  let r = { state: 0 };
  let info;
  let asset_is_zero = false;
  
  if (asset0 == TOKEN_WBNB) {
    info = await tokenInfo(asset1);
  } else if (asset1 == TOKEN_WBNB) {
    asset_is_zero = true;
    info = await tokenInfo(asset0);
  } else {
    console.log('pairCreated', pair, 'skip because not WBNB based', asset0, asset1);
    return;
  }
    
  if (!info.name) { return; }
  r = {router, pair, asset_is_zero, reserve0: 0, reserve1: 0, info};
    
  console.log('LP_CREATED', info.name, info.symbol, pair );
  lp_info[pair] = r;
  lp_list.push(pair);
}

async function lpSync(log) {
  let addr = log.address.toLowerCase();
  
  if (!interestingPair(addr)) { return; }
  
  let reserves = data_to_uint256(log.data);
  let reserve0 = BigInt(reserves[0]);
  let reserve1 = BigInt(reserves[1]);
  
  let bnb_bn = lp_info[addr].asset_is_zero ? reserve1 : reserve0;
  let bnb_float = parseFloat((bnb_bn / BigInt(10**15)).toString())/1000.0;
  
  if (lp_info[addr].reserve0 == 0 && lp_info[addr].reserve1 == 0) {
     console.log('LP_SYNC', lp_info[addr].info.name, 'Mint', reserve0.toString(), reserve1.toString(), 'BNB:', bnb_float.toFixed(4) );
  } else if ( (lp_info[addr].asset_is_zero && reserve0 > lp_info[addr].reserve0) || (!lp_info[addr].asset_is_zero && reserve1 > lp_info[addr].reserve1)) {
     console.log('LP_SYNC', lp_info[addr].info.name, 'Sell', reserve0.toString(), reserve1.toString(), 'BNB:', bnb_float.toFixed(4) );
  } else if ( (lp_info[addr].asset_is_zero && reserve1 > lp_info[addr].reserve1) || (!lp_info[addr].asset_is_zero && reserve0 > lp_info[addr].reserve0)) {
     console.log('LP_SYNC', lp_info[addr].info.name, 'Buy', reserve0.toString(), reserve1.toString(), 'BNB:', bnb_float.toFixed(4) );
  } else {
     console.log('**RUG**', lp_info[addr].info.name, 'RUG?', reserve0.toString(), reserve1.toString(), 'BNB:', bnb_float.toFixed(4), 'Old BNB:', lp_info[addr].bnb_float.toFixed(4) );
  }
  
  lp_info[addr].reserve0 = reserve0;
  lp_info[addr].reserve1 = reserve1;
  lp_info[addr].bnb_float = bnb_float;
  //console.log('lpSync', addr, reserves);
}

function topicRouter(error, log) {
  if (error) {
    console.error(error);
    return;
  }
  
  let addr = log.address.toLowerCase();
  
  if (log.topics[0] == PAIR_CREATED || interestingPair(addr)) {
     if (txnQueue.indexOf(log.transactionHash) == -1) {
       txnQueue.push( log.transactionHash );
     }
  }
}

/*
var deadmanTimer = null;
const DEADMAN_TIMEOUT = 30*1000;

function reconnect() {

   web3 = new Web3(endpoint);

   var block_headers = web3.eth.subscribe('newBlockHeaders', function(error, result){
      if (error) { console.log(result); return; }
      let { gasUsed, timestamp, number } = result;
      let this_block_time = Date.now();
      let lag = this_block_time - timestamp*1000.0;
      console.log(new Date(timestamp*1000.0).toString(), number, this_block_time - last_block_time, lag);
      last_block_time = this_block_time;

      if (deadmanTimer != null) { clearTimeout(deadmanTimer); }
      deadmanTimer = setTimeout( reconnect, DEADMAN_TIMEOUT );
   })
   .on("connected", (subscriptionId)=>{ console.log("BLOCK_HEADER CONNECTED", subscriptionId); })
   .on("error", (err)=>{ console.error(err); setTimeout(reconnect, 1000); });

   var logs_sub = web3.eth.subscribe('logs', { topics: [[PAIR_CREATED,LP_MINTED,LP_SYNC]] }, topicRouter)
       .on("connected", (subscriptionId)=>{ console.log("LOGS SUB CONNECTED", subscriptionId); })
       .on("error", (err)=>{ console.error(err); });

}

try {
   reconnect();
} catch(e) {
   console.error(e);
}
*/

let firstBlock = 19753746;
web3 = new Web3(process.env.BSC_RPC_URL);

let currentBlock = await web3.eth.getBlockNumber();
let lastBlock = currentBlock-128;

while (true) {

  let fromBlock = lastBlock+1;
  let req = { topics: [[PAIR_CREATED,LP_MINTED,LP_SYNC]], fromBlock };
  
  let logs = await web3.eth.getPastLogs(req);
  let txnDone = [];
  
  for (let log of logs) {
     let addr = log.address.toLowerCase();
  
     if (log.topics[0] == PAIR_CREATED || interestingPair(addr)) {
       if (txnDone.indexOf(log.transactionHash) == -1) {
          txnDone.push(log.transactionHash);

          let txn = await web3.eth.getTransactionReceipt(log.transactionHash);
          for (let log of txn.logs) {
             if (log.topics[0] == PAIR_CREATED) { await pairCreated(log); }
             if (log.topics[0] == LP_SYNC)      { await lpSync(log); }
          }
       }
     }
     
     if (log.blockNumber > lastBlock) {
       lastBlock = log.blockNumber;
     }
  }
  
  console.log('Done', fromBlock, '-', lastBlock, 'logs:', logs.length, 'txns:', txnDone.length );
  
  await setTimeout(10000);
}

