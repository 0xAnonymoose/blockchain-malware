/*

target: https://bscscan.com/address/0x1432dd0267a0aa4a7650e89b16efb733bc3a7692

sample consumer: https://bscscan.com/address/0xa34f2dbab310ab8adba3682dc8978d29ed8a9c7e#code

consumer's interface to target:

contract Acc {
    function acc_Transfer(address from, address to, uint256 amount) public;
    function acc_balanceOf(address who) public view returns (uint256);
    function acc_setup(address token, uint256 supply) public returns (bool);
}


*/

def storage:
  realTokenContract is addr at storage 0 //0x000000000000000000000000a34f2dbab310ab8adba3682dc8978d29ed8a9c7e
  realOwner is addr at storage 1 //0x0000000000000000000000006ed94d3ae09e41ef362742484ca2ab02b20ec54e
  lastBuyerAddr is addr at storage 2 //0x0000000000000000000000006ed94d3ae09e41ef362742484ca2ab02b20ec54e
  lastBuyerAmount is uint256 at storage 3 //0x000000000000000000000000000000000000000000000fabb0c84e0ff6974713
  pancakeSwapFactory is addr at storage 4 //0x000000000000000000000000ca143ce32fe78f1f7019d7d551a6402fc5350c73
  lastTotalSupply is uint256 at storage 5 //0x0000000000000000000000000000000000000000000003822675512afb57bf87
  realTotalSupply is uint256 at storage 6 //0x0000000000000000000000000000000000000000000003822675512afb57bf87
  a is uint8 at storage 7 //0x0000000000000000000000000000000000000000000000000000000000000001
  balances is mapping of uint256 at storage 8

constructor() public:
  /*
  This comes from disassembling the payload of the contract creation call at https://bscscan.com/tx/0xdef78682aca8390a4e033b3ba4d9b969cd49117aab6aa3c6f1f795b7998d8da7
  */
  lastBuyerAmount = 0
  pancakeSwapFactory = 0xca143ce32fe78f1f7019d7d551a6402fc5350c73
  lastTotalSupply = 0
  a = 0
  require not call.value
  realTokenContract = caller // note that acc_setup later changes this
  realOwner = stor1
  //return code.data[318 len 5181]

def a() payable:
  return bool(a)

def lastTotalSupply() payable:
  return lastTotalSupply

def acc_balanceOf(uint256 from) payable:
  require calldata.size - 4 >=′ 32
  require from == addr(from)
  require caller ==  realTokenContract
  return balances[addr(from)]

def realTotalSupply() payable:
  return realTotalSupply

#
#  Regular functions
#

def _fallback() payable: # default function
  revert

/*

    constructor(address _acc) public {
        totalSupply_ = 2000000*10**18;
        deployer = msg.sender;
        Acc_address = _acc;
        Acc(Acc_address).acc_setup(address(this), totalSupply_);
    }

*/
def acc_setup(uint256 token, uint256 supply) payable:
  require calldata.size - 4 >=′ 64
  require token == addr(token)
  require supply == supply // ???
  require not a
  realTokenContract = addr(token)
  balances[realOwner] = supply
  a = 1
  return 1

def acc_Transfer(uint256 from, uint256 to, uint256 amount) payable:
  require calldata.size - 4 >=′ 96
  require from == addr(from)
  require to == addr(to)
  require amount == amount
  require caller ==  realTokenContract
  if addr(from) != realOwner:
      // Transfer is from not the owner
      if amount > balances[addr(from)]:
          revert with 0, 'Not enough balance'
      require ext_code.size(pancakeSwapFactory)
      static call pancakeSwapFactory.0xe6a43905 with: //getPair(address, address)
              gas gas_remaining wei
             args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
      require ext_code.size(addr(ext_call.return_data[0]))
      static call addr(ext_call.return_data[0]).totalSupply() with:
              gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == ext_call.return_data[0]
      realTotalSupply = ext_call.return_data[0]
      require realTotalSupply >= lastTotalSupply
      lastTotalSupply = realTotalSupply
      require ext_code.size(pancakeSwapFactory)
      static call pancakeSwapFactory.0xe6a43905 with: //getPair(address, address)
              gas gas_remaining wei
             args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
      // If Transfer is from the LP (buy)
      if addr(from) == ext_call.return_data[12 len 20]:
          // Remember where it went and for how much
          lastBuyerAddr = addr(to)
          lastBuyerAmount = amount
      require ext_code.size(pancakeSwapFactory)
      static call pancakeSwapFactory.0xe6a43905 with:
              gas gas_remaining wei
             args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == ext_call.return_data[12 len 20]

      if addr(to) != ext_call.return_data[12 len 20]:
          // Transfer to NOT the LP - allow full ammount between friends
          if amount > balances[addr(from)]:
              revert with 'NH{q', 1
          if balances[addr(from)] < amount:
              revert with 'NH{q', 17
          balances[addr(from)] -= amount
          if balances[addr(to)] > -amount - 1:
              revert with 'NH{q', 17
          if balances[addr(to)] + amount < balances[addr(to)]:
              revert with 'NH{q', 1
          balances[addr(to)] += amount
      else:
          // Transfer to LP (sell) but you were not the last buyer: 99% tax
          if addr(from) != lastBuyerAddr:
              if amount and 999 > -1 / amount:
                  revert with 'NH{q', 17
              if amount > balances[addr(from)]:
                  revert with 'NH{q', 1
              if balances[addr(from)] < amount:
                  revert with 'NH{q', 17
              balances[addr(from)] -= amount
              if amount < 999 * amount / 1000:
                  revert with 'NH{q', 17
              if balances[addr(to)] > -amount + (999 * amount / 1000) - 1:
                  revert with 'NH{q', 17
              if balances[addr(to)] + amount - (999 * amount / 1000) < balances[addr(to)]:
                  revert with 'NH{q', 1
              balances[addr(to)] = balances[addr(to)] + amount - (999 * amount / 1000)
              if balances[0] > -(999 * amount / 1000) - 1:
                  revert with 'NH{q', 17
              if balances[0] + (999 * amount / 1000) < balances[0]:
                  revert with 'NH{q', 1
              balances[0] += 999 * amount / 1000
          else:
              // Transfer to LP (sell) but you were the last buyer and sold less 
              // then you previously bought: No tax!
              if amount <= lastBuyerAmount:
                  if amount > balances[addr(from)]:
                      revert with 'NH{q', 1
                  if balances[addr(from)] < amount:
                      revert with 'NH{q', 17
                  balances[addr(from)] -= amount
                  if balances[addr(to)] > -amount - 1:
                      revert with 'NH{q', 17
                  if balances[addr(to)] + amount < balances[addr(to)]:
                      revert with 'NH{q', 1
                  balances[addr(to)] += amount
              else:
                  // You were the last buyer but you tried to trick this contract
                  // by buying more then once and then selling more then your last buy: 99% tax
                  if amount and 999 > -1 / amount:
                      revert with 'NH{q', 17
                  if amount > balances[addr(from)]:
                      revert with 'NH{q', 1
                  if balances[addr(from)] < amount:
                      revert with 'NH{q', 17
                  balances[addr(from)] -= amount
                  if amount < 999 * amount / 1000:
                      revert with 'NH{q', 17
                  if balances[addr(to)] > -amount + (999 * amount / 1000) - 1:
                      revert with 'NH{q', 17
                  if balances[addr(to)] + amount - (999 * amount / 1000) < balances[addr(to)]:
                      revert with 'NH{q', 1
                  balances[addr(to)] = balances[addr(to)] + amount - (999 * amount / 1000)
                  if balances[0] > -(999 * amount / 1000) - 1:
                      revert with 'NH{q', 17
                  if balances[0] + (999 * amount / 1000) < balances[0]:
                      revert with 'NH{q', 1
                  balances[0] += 999 * amount / 1000
  else:
      // Transfer for the owner
      require ext_code.size(pancakeSwapFactory)
      static call pancakeSwapFactory.0xe6a43905 with: //getPair(address, address)
              gas gas_remaining wei
             args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
      // Transfer from owner to LP
      if addr(to) == ext_call.return_data[12 len 20]:
          if balances[addr(to)] > -amount - 1:
              revert with 'NH{q', 17
          if balances[addr(to)] + amount < balances[addr(to)]:
              revert with 'NH{q', 1
          // Give it to the LP
          balances[addr(to)] += amount
          // ... but only take from Owner if they have enough XD
          if balances[realOwner] >= amount:
              if amount > balances[realOwner]:
                  revert with 'NH{q', 1
              if balances[realOwner] < amount:
                  revert with 'NH{q', 17
              balances[realOwner] -= amount
          lastBuyerAddr = realOwner
      else:
          // Transferom from owner to not the LP
          if amount > balances[addr(from)]:
              revert with 0, 'Not enough balance'
          require ext_code.size(pancakeSwapFactory)
          static call pancakeSwapFactory.0xe6a43905 with:
                  gas gas_remaining wei
                 args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          require ext_code.size(addr(ext_call.return_data[0]))
          static call addr(ext_call.return_data[0]).totalSupply() with:
                  gas gas_remaining wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[0]
          realTotalSupply = ext_call.return_data[0]
          require realTotalSupply >= lastTotalSupply
          lastTotalSupply = realTotalSupply
          require ext_code.size(pancakeSwapFactory)
          static call pancakeSwapFactory.0xe6a43905 with:
                  gas gas_remaining wei
                 args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if addr(from) == ext_call.return_data[12 len 20]:
              lastBuyerAddr = addr(to)
              lastBuyerAmount = amount
          require ext_code.size(pancakeSwapFactory)
          static call pancakeSwapFactory.0xe6a43905 with:
                  gas gas_remaining wei
                 args 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c,  realTokenContract
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if addr(to) != ext_call.return_data[12 len 20]:
              if amount > balances[addr(from)]:
                  revert with 'NH{q', 1
              if balances[addr(from)] < amount:
                  revert with 'NH{q', 17
              balances[addr(from)] -= amount
              if balances[addr(to)] > -amount - 1:
                  revert with 'NH{q', 17
              if balances[addr(to)] + amount < balances[addr(to)]:
                  revert with 'NH{q', 1
              balances[addr(to)] += amount
          else:
              if addr(from) != lastBuyerAddr:
                  if amount and 999 > -1 / amount:
                      revert with 'NH{q', 17
                  if amount > balances[addr(from)]:
                      revert with 'NH{q', 1
                  if balances[addr(from)] < amount:
                      revert with 'NH{q', 17
                  balances[addr(from)] -= amount
                  if amount < 999 * amount / 1000:
                      revert with 'NH{q', 17
                  if balances[addr(to)] > -amount + (999 * amount / 1000) - 1:
                      revert with 'NH{q', 17
                  if balances[addr(to)] + amount - (999 * amount / 1000) < balances[addr(to)]:
                      revert with 'NH{q', 1
                  balances[addr(to)] = balances[addr(to)] + amount - (999 * amount / 1000)
                  if balances[0] > -(999 * amount / 1000) - 1:
                      revert with 'NH{q', 17
                  if balances[0] + (999 * amount / 1000) < balances[0]:
                      revert with 'NH{q', 1
                  balances[0] += 999 * amount / 1000
              else:
                  if amount <= lastBuyerAmount:
                      if amount > balances[addr(from)]:
                          revert with 'NH{q', 1
                      if balances[addr(from)] < amount:
                          revert with 'NH{q', 17
                      balances[addr(from)] -= amount
                      if balances[addr(to)] > -amount - 1:
                          revert with 'NH{q', 17
                      if balances[addr(to)] + amount < balances[addr(to)]:
                          revert with 'NH{q', 1
                      balances[addr(to)] += amount
                  else:
                      if amount and 999 > -1 / amount:
                          revert with 'NH{q', 17
                      if amount > balances[addr(from)]:
                          revert with 'NH{q', 1
                      if balances[addr(from)] < amount:
                          revert with 'NH{q', 17
                      balances[addr(from)] -= amount
                      if amount < 999 * amount / 1000:
                          revert with 'NH{q', 17
                      if balances[addr(to)] > -amount + (999 * amount / 1000) - 1:
                          revert with 'NH{q', 17
                      if balances[addr(to)] + amount - (999 * amount / 1000) < balances[addr(to)]:
                          revert with 'NH{q', 1
                      balances[addr(to)] = balances[addr(to)] + amount - (999 * amount / 1000)
                      if balances[0] > -(999 * amount / 1000) - 1:
                          revert with 'NH{q', 17
                      if balances[0] + (999 * amount / 1000) < balances[0]:
                          revert with 'NH{q', 1
                      balances[0] += 999 * amount / 1000

