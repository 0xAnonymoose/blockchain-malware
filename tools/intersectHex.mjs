const argv = process.argv;
import { readFileSync } from 'fs'
import { createHash } from 'crypto'

if (argv.length < 3) {
  console.log('Usage: node intersectHex.mjs file1 file2 .. fileN');
} else {

  let data = {};
  for (let i=2; i < argv.length; i++) {
    data[ argv[i] ] = readFileSync( argv[i], 'utf-8' );
  }
  
  let files = Object.keys(data);
  
  let datalen = data[files[0]].length;
  
  for (let i=0; i<files.length; i++) {
    if (data[files[i]].length != datalen) {
      console.log('ABORT: Size mismatch', files[i], ' != ', files[0]);
      datalen = null;
    }
  }

  const cSize = 32;  // chunk size in bytes)
  let p = 0;         // chunk pointer
  let c = null;      // start of current chunk (null if none active)
  let matched = [];  // list of matching chunk ranges
  
  if (datalen !== null) {
    while (p*cSize < datalen) {
      // check if all match
      let ref_chunk = data[files[0]].substring(p*cSize, (p+1)*cSize);
      let m = true;
      for (let i=1; i<files.length; i++) {
        let this_chunk = data[files[i]].substring(p*cSize, (p+1)*cSize);
        if (this_chunk != ref_chunk) { m = false; break; }
      }
      
      // run started
      if (m && c == null) { c=p; }

      // run ended
      if (!m || (p+1)*cSize >= datalen) {
        // did it have a start?
        if (c != null) {
          matched.push( [c,p] );
          c = null;
        } 
      }

      p++;
    }
  }

  console.log('Input length:', datalen);
  
  const min_match_length = 32; // *cSize
    
  for (let m of matched) {
    console.log('--------------------------------------');
      
    if (m[1]-m[0] < min_match_length) { 
      continue;
    }
    
    let offset = m[0]*cSize;
    let end = m[1]*cSize;
    if (end > datalen) { end = datalen; }
    let slice = data[files[0]].substring(offset,end);

    console.log(' Hash offsets: ', offset,'to',end);
    console.log(' Hash length: ', end-offset); 

    const hash = createHash('sha256').update(slice).digest('hex');
    console.log('    Checksum: ', hash);

  }
}
